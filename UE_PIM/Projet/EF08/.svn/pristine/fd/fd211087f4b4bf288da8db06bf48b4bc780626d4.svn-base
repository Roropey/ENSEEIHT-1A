with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_IO; use Ada.Text_IO;
with Flux_Binaire; use Flux_Binaire;
with Arbre;
with Liste_Chainee;

procedure Decompresser is
    -- Types
    
    package Liste_Chainee_Octet is
        new Liste_Chainee (T_Valeur => T_Octet);
    use Liste_Chainee_Octet;

    package Arbre_Integer_Octet is
        new Arbre (T_Cle => Integer, T_Valeur => T_Octet);
    use Arbre_Integer_Octet;

    type T_Flux_Fichier is record
        Flux_Interne : Stream_Access;
        Octet : T_Octet;
        Indice_Bit : Integer;
    end record;


    -- Variables

    Nom_Fichier : Unbounded_String;
    Fichier : Ada.Streams.Stream_IO.File_Type;
    Flux_Fichier_Brut : Stream_Access;
    Flux_Fichier : T_Flux_Fichier;

    Symbole_Fin : constant T_Octet := T_Octet'Last;
    
    Arbre_Huffman : T_Arbre;
    
    Trop_Arguments_Exception : Exception;
    Peu_Arguments_Exception : Exception;
    Fichier_Inexistant_Exception : Exception;
    Option_Inconnue_Exception : Exception;

    Affichage : Boolean;
    
    -- Sous-programmes

    procedure Initialiser (Flux_Fichier : out T_Flux_Fichier;
                           Flux_Interne : in Stream_Access) is
    begin
        Flux_Fichier.Flux_Interne := Flux_Interne;
        Flux_Fichier.Octet := 0;
        Flux_Fichier.Indice_Bit := 8;
    end Initialiser;


    function Lire_Bit (Flux_Fichier : in out T_Flux_Fichier) return T_Bit is
    begin
        if Flux_Fichier.Indice_Bit < 7 then
            Flux_Fichier.Indice_Bit := Flux_Fichier.Indice_Bit + 1;
        else
            Flux_Fichier.Indice_Bit := 0;
            Flux_Fichier.Octet := T_Octet'Input (Flux_Fichier.Flux_Interne);
        end if;

        return Le_Bit (Flux_Fichier.Octet, Flux_Fichier.Indice_Bit);
    end Lire_Bit;

    function Lire_Octet (Flux_Fichier : in out T_Flux_Fichier) return T_Octet is
    begin
        Flux_Fichier.Octet := T_Octet'Input (Flux_Fichier.Flux_Interne);

        return Flux_Fichier.Octet;
    end Lire_Octet;
    

    procedure Decoder_Liste_Positions (Flux_Fichier : in out T_Flux_Fichier;
                                       Liste_Positions : out T_Liste_Chainee) is
        Position_Symbole_Fin : Integer;
        Symbole : T_Octet;
        Dernier_Symbole : T_Octet;
    begin
        Initialiser (Liste_Positions);

        --  Lire et ajouter la position du symbole de fin
        Position_Symbole_Fin := Integer (Lire_Octet (Flux_Fichier));

        -- Lire les positions des autres symboles
        Symbole := Lire_Octet (Flux_Fichier);
        loop
            Ajouter (Liste_Positions, Symbole, False);
            Dernier_Symbole := Symbole;
            Symbole := Lire_Octet (Flux_Fichier);
        exit when Symbole = Dernier_Symbole;
        end loop;

        Inserer_Avant (Liste_Positions, Position_Symbole_Fin, Symbole_Fin);
    end Decoder_Liste_Positions;


    procedure Decoder_Structure_Arbre (Flux_Fichier : in out T_Flux_Fichier;
                                       Liste_Positions : in T_Liste_Chainee;
                                       Arbre_Huffman : out T_Arbre) is
        Position : Integer;

        procedure Decoder_Rec (Arbre_Huffman : out T_Arbre) is
            Bit : T_Bit;
        begin
            Initialiser (Arbre_Huffman);
            Bit := Lire_Bit (Flux_Fichier);

            if Bit = 1 then
                Enregistrer (Arbre_Huffman, 0,
                             La_Valeur (Liste_Positions, Position), null, null);
                Position := Position + 1;
            else
                Enregistrer (Arbre_Huffman, 0, 0, null, null);
                Decoder_Rec (Arbre_Huffman.all.Gauche);
                Decoder_Rec (Arbre_Huffman.all.Droite);
		    end if;
        end Decoder_Rec;
    begin
        Position := 0;
        Decoder_Rec (Arbre_Huffman);
    end Decoder_Structure_Arbre;


    procedure Recreer_Arbre_Huffman (Flux_Fichier : in out T_Flux_Fichier;
                                     Arbre_Huffman : out T_Arbre) is
        Liste_Positions : T_Liste_Chainee;
    begin
        -- Décoder la liste des positions
        Decoder_Liste_Positions (Flux_Fichier, Liste_Positions);

        -- Décoder la structure de l’arbre
        Decoder_Structure_Arbre (Flux_Fichier, Liste_Positions, Arbre_Huffman);
        
        Vider (Liste_Positions);
    end Recreer_Arbre_Huffman;


    function Decoder_Symbole (Flux_Fichier : in out T_Flux_Fichier;
                              Arbre_Huffman : in T_Arbre) return T_Octet is
        Noeud_Courant : T_Arbre;
    begin
        Noeud_Courant := Arbre_Huffman;

        if Est_Vide (Noeud_Courant) then
            -- TODO : raise Exception
            null;
        end if;

        while not Est_Vide (Noeud_Courant.Gauche) loop
            if Lire_Bit (Flux_Fichier) = 0 then
                Noeud_Courant := Noeud_Courant.Gauche;
            else
                Noeud_Courant := Noeud_Courant.Droite;
            end if;
        end loop;

        return Noeud_Courant.Valeur;
    end Decoder_Symbole;


    procedure Reconstruire_Fichier_Original (Flux_Fichier : in out T_Flux_Fichier;
                                             Arbre_Huffman : in T_Arbre) is
        -- Nom_Fichier_Decompresse := Nom_Fichier - ".hff"
        Nom_Fichier_Decompresse : constant String :=
            To_String(Nom_Fichier) (1 .. (To_String(Nom_Fichier)'Length - 4));

        Fichier_Decompresse : Ada.Streams.Stream_IO.File_Type;
        Flux_Fichier_Decompresse : Stream_Access;

        Symbole : T_Octet;
        Est_Fin_Du_Fichier : Boolean;
    begin
        --  Créer et ouvrir le fichier Nom_Fichier_Decompresse
        Create (Fichier_Decompresse, Out_File, Nom_Fichier_Decompresse);
        Flux_Fichier_Decompresse := Stream (Fichier_Decompresse);

        -- Décoder les octets de Nom_Fichier dans Nom_Fichier_Decompresse
        Est_Fin_Du_Fichier := False;
        while not Est_Fin_Du_Fichier loop
            Symbole := Decoder_Symbole (Flux_Fichier, Arbre_Huffman);
            Est_Fin_Du_Fichier := Symbole = Symbole_Fin;

            if not Est_Fin_Du_Fichier then
                T_Octet'Write (Flux_Fichier_Decompresse, Symbole);
            end if;
        end loop;

        Close (Fichier_Decompresse);
    end Reconstruire_Fichier_Original;

    procedure Recuperer_Infos_Utilisateur(Affichage : out Boolean; Nom_Fichier : out Unbounded_String) is 
    begin
        Affichage := False;
        if Argument_Count > 2 then
            raise Trop_Arguments_Exception;
        elsif Argument_Count = 1 then
            -- Récupérer les arguments de la ligne de commande
            Nom_Fichier := To_Unbounded_String(Argument(1));
        elsif Argument_Count = 0 then
            --Nom_Fichier := To_Unbounded_String("exemple.txt");
            raise Peu_Arguments_Exception;
        else
            if Argument(1) = "-b" or Argument(1) = "--bavard" then
                Affichage := True;
                Nom_Fichier := To_Unbounded_String(Argument(2));
            else
                raise Option_Inconnue_Exception;                
            end if;
        end if;
    end Recuperer_Infos_Utilisateur;
    
begin
    -- Déterminer Nom_Fichier avec les arguments de la ligne de commande
    Recuperer_Infos_Utilisateur(Affichage,Nom_Fichier);

    -- Ouvrir le fichier Nom_Fichier
    begin
        Open (Fichier, In_File, To_String(Nom_Fichier));
    exception
        when Ada.Text_IO.Name_Error => raise Fichier_Inexistant_Exception;
    end;
    Flux_Fichier_Brut := Stream (Fichier);
    Initialiser (Flux_Fichier, Flux_Fichier_Brut);

    -- Recréer l’arbre de Huffman
    Recreer_Arbre_Huffman (Flux_Fichier, Arbre_Huffman);

    -- Reconstruire le fichier original
    Reconstruire_Fichier_Original (Flux_Fichier, Arbre_Huffman);

    Close (Fichier);  -- TODO procedure fermer
    Vider (Arbre_Huffman);

exception
    
    when Trop_Arguments_Exception => Put_Line("Vous avez entré trop d'arguments.");
    when Peu_Arguments_Exception => Put_Line("Vous n'avez pas entré d'arguments.");
    when Fichier_Inexistant_Exception => Put_Line("Fichier à compresser inexistant.");
    when Option_Inconnue_Exception => Put_Line("Option entrée non reconnue.");
    
 
end Decompresser;
